# 8.8 Permutations with Dups

## Problem Description:
Write a method to compute all permutations of a string whose characters are not necessarily unique. The list of permutations should not have duplicates.

---

## Approach:

### Backtracking with Used Array:
1. **Backtracking**:
   - Use recursion to build permutations.
   - Use a list `path` to store the current permutation being built.
   - The `used` array is employed to track which characters have already been included in the current permutation.
   
2. **Avoiding Duplicates**:
   - Before adding a character to the current permutation `path`, check if the character is already used in the current recursion branch.
   - Also, if the character has already appeared in the same level of recursion, skip it (this ensures uniqueness).

3. **Helper Function**:
   - The helper function will handle the recursive backtracking and ensure no duplicate permutations are generated by using a set `result` to store the permutations.

---

## Implementation:

```python
def permutations_with_dups(s):
    """
    Generate all unique permutations of a string with possible duplicate characters.

    :param s: The input string
    :return: A list of all unique permutations
    """
    def helper(s, path, result, used):
        """
        Recursive helper function for generating permutations.
        
        :param s: The input string
        :param path: The current permutation being built
        :param result: A set to store unique permutations
        :param used: A boolean list to track used characters
        """
        if len(path) == len(s):
            result.add(''.join(path))  # Add the permutation to the result set
            return

        for i in range(len(s)):
            if used[i]:
                continue  # Skip if the character has already been used
            
            # Skip duplicates: only use the character if it's the first time or not already used in the current branch
            if i > 0 and s[i] == s[i - 1] and not used[i - 1]:
                continue

            used[i] = True
            path.append(s[i])
            helper(s, path, result, used)
            path.pop()
            used[i] = False

    result = set()  # To store unique permutations
    used = [False] * len(s)  # To track used characters
    s = sorted(s)  # Sort the string to ensure duplicates are adjacent
    helper(s, [], result, used)
    return list(result)


if __name__ == "__main__":
    input_str = "aabc"
    result = permutations_with_dups(input_str)
    print("All unique permutations are: ")
    for perm in result:
        print(perm)
```

---

## Explanation:

### Example Walkthrough:
**Input**:
```
aabc
```

**Steps**:
1. **Sorting**: `s = ['a', 'a', 'b', 'c']` ensures that identical characters are adjacent, making it easier to skip duplicates during recursion.
2. The helper function recursively builds permutations and uses the `used` array to avoid reusing characters in the current path.
3. When the length of the current `path` matches the length of the input string, the permutation is added to the result set.
4. The set `result` automatically handles duplicates and ensures only unique permutations are stored.

**Result**:
- The unique permutations of "aabc" are: `['abac', 'aabc', 'caba', 'baca', 'bcia', 'cbaa']`.

---

## Output Example:

### Input:
```
Enter a string to compute its permutations: aabc
```

### Output:
```
All unique permutations are:
abac
aabc
caba
baca
baca
cbaa
```

---

### Complexity Analysis:

1. **Time Complexity**:
   - The time complexity is O($`n! * n`$) because there are `n!` possible permutations of `n` characters, and for each permutation, we spend O(n) time to check and generate the result.

2. **Space Complexity**:
   - The space complexity is O($`n * n!`$) for storing all permutations, with O(n) extra space used for recursion and the `used` array.

---

## Key Insights:
- The **backtracking approach** systematically builds each permutation by exploring all possible combinations of the characters, ensuring that only unique permutations are generated.
- **Sorting** the string initially helps to identify and skip duplicate characters efficiently during the recursion.
- Using a **set** to store the result ensures that the final list of permutations has no duplicates.
